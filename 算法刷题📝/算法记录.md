## 前缀和
***
可以跳脱出来用高中数学的数列知识来看，其实也就是数列的知识。
***
具体做法，做一个预处理，定义一个`sum[]` 数组，`sum[i]`代表`a` 数组中前`i`个数的和
```
const int N = 1e5+10;
int sum[N], a[N];
for(int i = 1; i <= n; i ++) {
	sum[i] = sum[i - 1] + a[i];
}
```

通过这样的操作使得取出原序列中第`l`个数到第`r`个数的和的时间复杂度变为了`O(1)`, 以上为一维前缀和。
*核心思想：*   `空间换时间`将要用到的数东西提前计算好存起来，后续要使用时可以直接使用。
不然按照老的思路是会开一个循环然后再来加。 
### 二维前缀和

直接给代码；
```
for(int i = 1; i <= n; i ++) {
	for(int j = 1; j <= n; j ++) {
		b[i][j] = b[i-1][j] + b[i][j-1] - b[i-1][j-1] + a[i][j]'
	}
}
```

![image.png](https://raw.githubusercontent.com/KrealHtz/NoteImage/master/data/202404012338218.png)

## 差分
差分可以看作前缀和的逆运算。
对比一维前缀和：b[i] = b[i-1] + a[i];  将这个公式变形，可以得到a[i] = b[i] - b[i-1];
作用也是空间换时间，存下来了一些中间过程。
当要操作一大串连续的数时，就不需要直接遍历整个数组一个一个操作。`通过差分可以快速改变一个区间内的所有值`
如果对a[i]的一个下标为r的数字值加c，那么它会对前缀和产生影响，即会将所有的从下标r开始的前缀和都➕上一个c；如果对下标`l`的数字➖一个c即会将`l`开始后的所有减去一个c。
这样就操作了`l`到`r` 这个区间。
题目链接 [[https://www.acwing.com/problem/content/description/799/]]
输入一个长度为 n的整数序列。
接下来输入 m 个操作，每个操作包含三个整数 l,r,c表示将序列中 [l,r][�,�] 之间的每个数加上 c。
请你输出进行完所有操作后的序列.
题解：
```
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 100010;

int a[N];
int s[N];

int n,  m;
int main()
{
    cin >> n >> m;
    // 读入数组 a
    for (int i = 1; i <= n; i ++ ) cin >> a[i];
    // 构造差分数组 b
    for (int i = 1; i <= n; i ++ ) b[i] = a[i] - a[i - 1];
    // 执行m次操作
    while(m--)
    {
        int l, r, k;
        // 区间操作转换为两点操作
        cin >> l >> r >> k;
        b[l] += k;
        b[r + 1] -= k;
    }
    // 通过前缀和，还原数组a
    for (int i = 1; i <= n; i ++ )
    {
        a[i] = a[i - 1] + b[i];
        // 输出结果
        cout <<a[i]<<" ";
    }
    return 0;
}
```

### 二维差分
类比二维前缀和可推倒
```
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 1e3 + 10;
int a[N][N], b[N][N];
void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
int main()
{
    int n, m, q;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            insert(i, j, i, j, a[i][j]);      //构建差分数组
        }
    }
    while (q--)
    {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  //二维前缀和
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            printf("%d ", b[i][j]);
        }
        printf("\n");
    }
    return 0;
}

```

## 并查集
